<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Tooling.tt" #>
<#@ output extension=".cs" #>
using IX.Retry.StandardPolicies;
using System;
using System.Collections.Generic;

namespace IX.Retry
{
    public static partial class Policy
    {
        /// <summary>
        /// A time-based, non-linear retry policy.
        /// </summary>
        /// <param name="retryDuration">The retry duration for this time-based policy.</param>
        /// <param name="retryForExceptionTypes">Retry for certain exception types.</param>
        /// <returns>A time-based retry policy instance.</returns>
        public static IRetryPolicy TimeBased(TimeSpan retryDuration, IEnumerable<Type> retryForExceptionTypes)
        {
            return new TimeBasedRetryPolicy(retryDuration, retryForExceptionTypes);
        }

        /// <summary>
        /// A time-based, non-linear retry policy.
        /// </summary>
        /// <param name="retryDuration">The retry duration for this time-based policy.</param>
        /// <param name="backOffPolicy">A back-off policy to apply between attempts. This policy is always time-based.</param>
        /// <param name="retryForExceptionTypes">Retry for certain exception types.</param>
        /// <returns>A time-based retry policy instance.</returns>
        public static IRetryPolicy TimeBased(TimeSpan retryDuration, BackOffPolicy backOffPolicy, IEnumerable<Type> retryForExceptionTypes)
        {
            return new TimeBasedRetryPolicy(retryDuration, backOffPolicy, retryForExceptionTypes);
        }

        /// <summary>
        /// A time-based, non-linear retry policy that retries on a specific exception.
        /// </summary>
        /// <typeparam name="TException">The exception type to capture and retry on.</typeparam>
        /// <param name="retryDuration">The retry duration for this time-based policy.</param>
        /// <returns>A time-based retry policy instance.</returns>
        public static IRetryPolicy TimeBased<TException>(TimeSpan retryDuration)
            where TException : Exception
        {
            return new TimeBasedRetryPolicy<TException>(retryDuration);
        }

        /// <summary>
        /// A time-based, non-linear retry policy that retries on a specific exception and has a specific back-off policy.
        /// </summary>
        /// <typeparam name="TException">The exception type to capture and retry on.</typeparam>
        /// <param name="maximumRetries">The maximum retry count for this count-based policy.</param>
        /// <param name="backOffPolicy">A back-off policy to apply between attempts. This policy is always time-based.</param>
        /// <returns>A time-based retry policy instance.</returns>
        public static IRetryPolicy TimeBased<TException>(TimeSpan retryDuration, BackOffPolicy backOffPolicy)
            where TException : Exception
        {
            return new TimeBasedRetryPolicy(retryDuration, backOffPolicy, typeof(TException));
        }
<#
for (int i = 2; i <= 16; i++)
{
    List<string> exceptionTypeParameters = new List<string>();
    for (int j = 1; j <= i; j++)
    {
        exceptionTypeParameters.Add(string.Format("TException{0}", j));
    }
    string exceptionTypeParams = string.Join(", ", exceptionTypeParameters);
#>

        /// <summary>
        /// A time-based, non-linear retry policy that retries on a specific set of exceptions and has a specific back-off policy.
        /// </summary>
<#
    string exceptionTypeParamTypes = string.Join("), typeof(", exceptionTypeParameters);
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TException<#=j#>">An exception type to capture and retry on.</typeparam>
<#
    }
#>
        /// <param name="retryDuration">The retry duration for this time-based policy.</param>
        /// <param name="backOffPolicy">A back-off policy to apply between attempts. This policy is always time-based.</param>
        /// <returns>A time-based retry policy instance.</returns>
        public static IRetryPolicy TimeBased<<#=exceptionTypeParams#>>(TimeSpan retryDuration, BackOffPolicy backOffPolicy)
<#
    for (int j = 1; j <= i; j++)
    {
#>
            where TException<#=j#> : Exception
<#
    }
#>
        {
            return new TimeBasedRetryPolicy(retryDuration, backOffPolicy, typeof(<#=exceptionTypeParamTypes#>));
        }

        /// <summary>
        /// A time-based, non-linear retry policy that retries on a specific set of exceptions and has a specific back-off policy.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="TException<#=j#>">An exception type to capture and retry on.</typeparam>
<#
    }
#>
        /// <param name="retryDuration">The retry duration for this time-based policy.</param>
        /// <returns>A time-based retry policy instance.</returns>
        public static IRetryPolicy TimeBased<<#=exceptionTypeParams#>>(TimeSpan retryDuration)
<#
    for (int j = 1; j <= i; j++)
    {
#>
            where TException<#=j#> : Exception
<#
    }
#>
        {
            return new TimeBasedRetryPolicy(retryDuration, typeof(<#=exceptionTypeParamTypes#>));
        }
<#
}
#>
    }
}<#
    FlushOutput("Policy_TimeBased.cs");
#>