<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="Tooling.tt" #>
<#@ output extension=".cs" #>
using System;
using System.Threading;

namespace IX.Retry
{
    public static partial class With
    {
        /// <summary>
        /// Invokes a <see cref="System.Func{TResult}"/> with a retry policy and a cancellation token.
        /// </summary>
        /// <typeparam name="TResult">The result of the call.</typeparam>
        /// <param name="func">The function to execute with retry.</param>
        /// <param name="retryPolicy">A retry policy to apply to the function.</param>
        /// <param name="cancellationToken">The task's (optional) <see cref="System.Threading.CancellationToken"/>.</param>
        /// <returns>The result of the operation, after retries, of the type <typeparamref name="TResult"/>.</returns>
        public static TResult Retry<TResult>(Func<TResult> func, IRetryPolicy retryPolicy, CancellationToken cancellationToken = default(CancellationToken))
        {
            return func.WithRetry(retryPolicy, cancellationToken);
        }

        /// <summary>
        /// Invokes a <see cref="System.Func{T, TResult}"/> with a retry policy and a cancellation token.
        /// </summary>
        /// <typeparam name="T">The first function parameter type.</typeparam>
        /// <typeparam name="TResult">The result of the call.</typeparam>
        /// <param name="func">The function to execute with retry.</param>
        /// <param name="retryPolicy">A retry policy to apply to the function.</param>
        /// <param name="arg">The first function parameter, of the type specified in <typeparamref name="T"/>. This parameter is not null-checked and is forwarded directly to the function.</param>
        /// <param name="cancellationToken">The task's (optional) <see cref="System.Threading.CancellationToken"/>.</param>
        /// <returns>The result of the operation, after retries, of the type <typeparamref name="TResult"/>.</returns>
        public static TResult Retry<T, TResult>(Func<T, TResult> func, IRetryPolicy retryPolicy, T arg, CancellationToken cancellationToken = default(CancellationToken))
        {
            return func.WithRetry(retryPolicy, arg, cancellationToken);
        }
<#
for (int i = 2; i <= 16; i++)
{
    List<string> exceptionTypeParameters = new List<string>();
    List<string> exceptionParameters = new List<string>();
    List<string> exceptionParams = new List<string>();
    for (int j = 1; j <= i; j++)
    {
        exceptionTypeParameters.Add(string.Format("T{0}", j));
        exceptionParameters.Add(string.Format("T{0} arg{0}", j));
        exceptionParams.Add(string.Format("arg{0}", j));
    }
    string exceptionTypeParametersString = string.Join(", ", exceptionTypeParameters);
    string exceptionParametersString = string.Join(", ", exceptionParameters);
    string exceptionParamsString = string.Join(", ", exceptionParams);
#>

        /// <summary>
        /// Invokes a <see cref="System.Func{<#=exceptionTypeParametersString#>, TResult}"/> with a retry policy and a cancellation token.
        /// </summary>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <typeparam name="T<#=j#>">Function parameter type no. <#=j#>.</typeparam>
<#
    }
#>
        /// <typeparam name="TResult">The result of the call.</typeparam>
        /// <param name="func">The function to execute with retry.</param>
        /// <param name="retryPolicy">A retry policy to apply to the function.</param>
<#
    for (int j = 1; j <= i; j++)
    {
#>
        /// <param name="arg<#=j#>">Function parameter no. <#=j#>, of the type specified in <typeparamref name="T<#=j#>"/>. This parameter is not null-checked and is forwarded directly to the function.</param>
<#
    }
#>
        /// <param name="cancellationToken">The task's (optional) <see cref="System.Threading.CancellationToken"/>.</param>
        /// <returns>The result of the operation, after retries, of the type <typeparamref name="TResult"/>.</returns>
        public static TResult Retry<<#=exceptionTypeParametersString#>, TResult>(Func<<#=exceptionTypeParametersString#>, TResult> func, IRetryPolicy retryPolicy, <#=exceptionParametersString#>, CancellationToken cancellationToken = default(CancellationToken))
        {
            return func.WithRetry(retryPolicy, <#=exceptionParamsString#>, cancellationToken);
        }
<#
}
#>
    }
}
<#
    FlushOutput(@"With_FuncReturningResult.cs");
#>